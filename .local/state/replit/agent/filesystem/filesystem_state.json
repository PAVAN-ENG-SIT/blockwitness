{"file_contents":{"README.md":{"content":"---\n\n# Localhost Installation & Running Instructions\n\nThese steps run BlockWitness **fully on localhost**.\n\n---\n\n## 1️⃣ Backend Setup (Flask API)\n\n```powershell\ncd blockwitness/backend\n\n# Create virtual env (first time)\npython -m venv venv\n\n# Activate venv\nvenv\\Scripts\\Activate.ps1\n\n# Install dependencies\npip install flask flask-cors\npip install reportlab qrcode[pil]   # for PDF + QR\n\n# Start backend\npython app.py\n\n\nBackend will run at:\n\n```\nhttp://127.0.0.1:5001\n```\n\n---\n\n## 2️⃣ Frontend Setup (React + Vite)\n\nOpen a NEW PowerShell window:\n\n```powershell\ncd blockwitness/frontend\n\n# Install node modules\nnpm install\n\n# Start frontend\nnpm run dev\n```\n\nFrontend will run at:\n\n```\nhttp://localhost:5173\n```\n\n---\n\n## 3️⃣ Quick Local Test\n\n1. Open `http://localhost:5173`\n2. Go to **Create Report**\n3. Fill details + upload any image\n\n   * You may use this sample file if needed:\n     `/mnt/data/8c099852-aacd-4177-bd7b-db36ae98c0d2.png`\n4. Submit\n5. Open **Explorer** → new block appears\n6. Test:\n\n   * Merkle Path\n   * PDF Download\n   * Verify Chain\n   * Timeline\n   * Search\n   * File Verification\n\nEverything works **completely offline** on `localhost`.\n\n---\n\n```\n\n---\n","size_bytes":1188},"backend/check_db.py":{"content":"import sqlite3\n\nconn = sqlite3.connect(\"chain.db\")\nc = conn.cursor()\n\nprint(\"\\n--- TRANSACTIONS TABLE ---\")\nfor row in c.execute(\"SELECT tx_id, report_id, title, uploader, metadata, block_idx FROM transactions\"):\n    print(row)\n\nprint(\"\\n--- BLOCKS TABLE ---\")\nfor row in c.execute(\"SELECT idx, timestamp, previous_hash, merkle_root, block_hash FROM blocks\"):\n    print(row)\n\nconn.close()\n","size_bytes":389},"frontend/src/components/MerkleVisualizer.jsx":{"content":"// frontend/src/components/MerkleVisualizer.jsx\nimport React, { useMemo } from \"react\";\n\n/**\n * Props:\n *  - proof: [{ sibling: <hex>, position: 'left'|'right' }, ...]\n *  - leaf: string\n *  - root: string\n *  - valid: boolean\n */\nexport default function MerkleVisualizer({ proof = [], leaf = \"\", root = \"\", valid = false }) {\n  const computedRoot = useMemo(() => {\n    if (!leaf || !proof) return null;\n    let cur = leaf;\n    for (const p of proof) {\n      const sib = p.sibling;\n      if (p.position === \"left\") {\n        cur = window.sha256 ? window.sha256(sib + cur) : null;\n      } else {\n        cur = window.sha256 ? window.sha256(cur + sib) : null;\n      }\n      // If window.sha256 not available, we still show proof structure visually\n    }\n    return cur;\n  }, [proof, leaf]);\n\n  return (\n    <div>\n      <div className=\"mb-3\">\n        <strong>Merkle Root (expected):</strong>\n        <div className=\"font-mono bg-gray-100 p-2 rounded mt-1 break-all\">{root}</div>\n      </div>\n\n      <div className=\"mb-3\">\n        <strong>Leaf:</strong>\n        <div className=\"font-mono bg-gray-100 p-2 rounded mt-1 break-all\">{leaf}</div>\n      </div>\n\n      <div className=\"mb-3\">\n        <strong>Proof steps:</strong>\n        <ol className=\"list-decimal ml-6\">\n          {proof && proof.map((p, i) => (\n            <li key={i} className=\"mb-2\">\n              <div className=\"text-sm\">Sibling: <span className=\"font-mono break-all\">{p.sibling}</span></div>\n              <div className=\"text-sm\">Position: {p.position}</div>\n            </li>\n          ))}\n        </ol>\n      </div>\n\n      <div className=\"mt-4\">\n        <div>\n          <strong>Proof verification:</strong>\n          <div className=\"mt-1\">\n            {valid ? <span className=\"text-green-600 font-semibold\">VALID — reconstructed root matches</span> : <span className=\"text-red-600 font-semibold\">INVALID — proof does not match root</span>}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n","size_bytes":1975},"frontend/src/pages/Timeline.jsx":{"content":"// frontend/src/pages/Timeline.jsx\nimport React, { useEffect, useState } from \"react\";\nimport { getTimeline } from \"../api\";\n\nexport default function Timeline() {\n  const [blocks, setBlocks] = useState([]);\n\n  useEffect(()=>{ load(); }, []);\n\n  async function load() {\n    try {\n      const res = await getTimeline();\n      setBlocks(res);\n    } catch(err) {\n      alert(\"Failed to load timeline: \" + err.message);\n    }\n  }\n\n  return (\n    <div className=\"p-6 max-w-4xl mx-auto\">\n      <h1 className=\"text-2xl font-semibold mb-4\">Chain Timeline</h1>\n      <div className=\"space-y-4\">\n        {blocks.map(b => (\n          <div key={b.idx} className=\"bg-white p-4 rounded shadow\">\n            <div className=\"flex justify-between items-center\">\n              <div>\n                <div className=\"font-bold\">Block #{b.idx}</div>\n                <div className=\"text-xs text-gray-600\">{b.timestamp}</div>\n                <div className=\"text-xs text-gray-600\">Hash: {b.block_hash?.slice(0,12)}...</div>\n              </div>\n              <div className=\"text-sm text-gray-700\">Transactions: {b.transactions.length}</div>\n            </div>\n\n            <div className=\"mt-3\">\n              <ul className=\"ml-4 list-disc text-sm\">\n                {b.transactions.map(tx => (\n                  <li key={tx.tx_id}><b>{tx.title}</b> — {tx.uploader} — <span className=\"text-xs text-gray-500\">{tx.tx_id}</span></li>\n                ))}\n              </ul>\n            </div>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n","size_bytes":1531},"frontend/src/index.css":{"content":"@import \"tailwindcss\";\n","size_bytes":23},"frontend/src/App.jsx":{"content":"// frontend/src/App.jsx\nimport React from \"react\";\nimport { BrowserRouter, Routes, Route, Link } from \"react-router-dom\";\nimport CreateReport from \"./pages/CreateReport\";\nimport Explorer from \"./pages/Explorer\";\nimport Verify from \"./pages/Verify\";\nimport Search from \"./pages/Search\";\nimport Timeline from \"./pages/Timeline\";\n\nexport default function App(){\n  return (\n    <BrowserRouter>\n      <div className=\"min-h-screen bg-slate-100\">\n        <nav className=\"bg-white px-6 py-3 shadow\">\n          <div className=\"max-w-6xl mx-auto flex items-center justify-between\">\n            <div className=\"font-bold text-lg\">BlockWitness</div>\n            <div className=\"flex gap-4 items-center\">\n              <Link to=\"/\" className=\"text-sm text-indigo-600\">Create</Link>\n              <Link to=\"/explorer\" className=\"text-sm text-indigo-600\">Explorer</Link>\n              <Link to=\"/verify\" className=\"text-sm text-indigo-600\">Verify</Link>\n              <Link to=\"/search\" className=\"text-sm text-indigo-600\">Search</Link>\n              <Link to=\"/timeline\" className=\"text-sm text-indigo-600\">Timeline</Link>\n            </div>\n          </div>\n        </nav>\n\n        <main className=\"max-w-6xl mx-auto py-8\">\n          <Routes>\n            <Route path=\"/\" element={<CreateReport />} />\n            <Route path=\"/explorer\" element={<Explorer />} />\n            <Route path=\"/verify\" element={<Verify />} />\n            <Route path=\"/search\" element={<Search />} />\n            <Route path=\"/timeline\" element={<Timeline />} />\n          </Routes>\n        </main>\n      </div>\n    </BrowserRouter>\n  );\n}\n","size_bytes":1605},"backend/crypto_utils.py":{"content":"# backend/crypto_utils.py\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Signature import pkcs1_15\nfrom Crypto.Hash import SHA256\n\ndef sign_hex(priv_pem_path, hex_message):\n    key = RSA.import_key(open(priv_pem_path,'rb').read())\n    h = SHA256.new(bytes.fromhex(hex_message))\n    signature = pkcs1_15.new(key).sign(h)\n    return signature.hex()\n\ndef verify_hex(pub_pem_path, hex_message, signature_hex):\n    key = RSA.import_key(open(pub_pem_path,'rb').read())\n    h = SHA256.new(bytes.fromhex(hex_message))\n    try:\n        pkcs1_15.new(key).verify(h, bytes.fromhex(signature_hex))\n        return True\n    except (ValueError, TypeError):\n        return False\n","size_bytes":660},"frontend/src/pages/Search.jsx":{"content":"// frontend/src/pages/Search.jsx\nimport React, { useState } from \"react\";\nimport { searchReports } from \"../api\";\n\nexport default function Search() {\n  const [query, setQuery] = useState(\"\");\n  const [results, setResults] = useState([]);\n  const [loading, setLoading] = useState(false);\n\n  async function handleSearch() {\n    if (!query) return setResults([]);\n    setLoading(true);\n    try {\n      console.log(\"[Search] calling API for:\", query);\n      const res = await searchReports(query);\n      console.log(\"[Search] API returned:\", res);\n      setResults(res || []);\n    } catch (err) {\n      console.error(\"[Search] API error:\", err);\n      alert(\"Search failed: \" + err.message);\n      setResults([]);\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  return (\n    <div className=\"p-6 max-w-3xl mx-auto\">\n      <h1 className=\"text-3xl font-bold mb-4\">Search Reports</h1>\n      <div className=\"flex gap-3 mb-6\">\n        <input\n          className=\"flex-1 px-4 py-2 border rounded\"\n          value={query}\n          onChange={(e) => setQuery(e.target.value)}\n          placeholder=\"Search by title, uploader, tx_id, block...\"\n        />\n        <button onClick={handleSearch} className=\"px-4 py-2 bg-blue-600 text-white rounded\">\n          {loading ? \"Searching...\" : \"Search\"}\n        </button>\n      </div>\n\n      <div>\n        <p className=\"text-sm text-gray-500 mb-2\">Open browser console (F12) to see request/response logs.</p>\n        {results.length === 0 && query && !loading && <p className=\"text-gray-500\">No results found.</p>}\n        <ul className=\"space-y-4\">\n          {results.map((r) => (\n            <li key={r.tx_id} className=\"p-4 bg-white rounded shadow\">\n              <h2 className=\"text-xl font-semibold\">{r.title}</h2>\n              <p className=\"text-gray-600\">{r.description}</p>\n              <p className=\"mt-2 text-sm\"><b>Uploader:</b> {r.uploader}</p>\n              <p className=\"text-sm\"><b>Block:</b> {r.block_index}</p>\n              <p className=\"text-sm\"><b>TX ID:</b> {r.tx_id}</p>\n            </li>\n          ))}\n        </ul>\n      </div>\n    </div>\n  );\n}\n","size_bytes":2106},"frontend/src/pages/CreateReport.jsx":{"content":"// frontend/src/pages/CreateReport.jsx\nimport React, { useState } from \"react\";\nimport { createReport } from \"../api\";\n\nexport default function CreateReport() {\n  const [title, setTitle] = useState(\"\");\n  const [desc, setDesc] = useState(\"\");\n  const [uploader, setUploader] = useState(\"demo_user\");\n  const [files, setFiles] = useState([]);\n  const [result, setResult] = useState(null);\n  const [loading, setLoading] = useState(false);\n\n  function onFiles(e) {\n    setFiles(Array.from(e.target.files));\n  }\n\n  async function submit(e) {\n    e.preventDefault();\n    setLoading(true);\n    const fd = new FormData();\n    fd.append(\"title\", title);\n    fd.append(\"description\", desc);\n    fd.append(\"uploader\", uploader);\n    for (const f of files) fd.append(\"files\", f);\n    try {\n      const r = await createReport(fd);\n      setResult(r);\n    } catch (err) {\n      alert(\"Upload failed: \" + err.message);\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  return (\n    <div className=\"p-6 max-w-3xl mx-auto\">\n      <h1 className=\"text-2xl font-semibold mb-4\">Create Incident Report</h1>\n      <form onSubmit={submit} className=\"bg-white p-6 rounded shadow\">\n        <label className=\"block mb-2\">Title\n          <input className=\"w-full p-2 border mt-1\" value={title} onChange={(e)=>setTitle(e.target.value)} />\n        </label>\n        <label className=\"block mb-2\">Description\n          <textarea className=\"w-full p-2 border mt-1\" value={desc} onChange={(e)=>setDesc(e.target.value)} />\n        </label>\n        <label className=\"block mb-2\">Uploader\n          <input className=\"w-full p-2 border mt-1\" value={uploader} onChange={(e)=>setUploader(e.target.value)} />\n        </label>\n        <label className=\"block mb-4\">Evidence files\n          <input type=\"file\" multiple onChange={onFiles} className=\"w-full mt-1\" />\n        </label>\n        <button className=\"px-4 py-2 bg-indigo-600 text-white rounded\">\n          {loading ? \"Submitting...\" : \"Submit\"}\n        </button>\n      </form>\n\n      {result && (\n        <div className=\"mt-6 bg-white p-4 rounded shadow\">\n          <h2 className=\"font-semibold\">Report created</h2>\n          <pre className=\"text-sm\">{JSON.stringify(result, null, 2)}</pre>\n        </div>\n      )}\n    </div>\n  );\n}\n","size_bytes":2253},"frontend/README.md":{"content":"# React + Vite\n\nThis template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.\n\nCurrently, two official plugins are available:\n\n- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh\n- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh\n\n## React Compiler\n\nThe React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).\n\n## Expanding the ESLint configuration\n\nIf you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.\n","size_bytes":1157},"frontend/src/pages/Verify.jsx":{"content":"// frontend/src/pages/Verify.jsx\nimport React, { useState } from \"react\";\nimport { verifyFile } from \"../api\";\n\nexport default function Verify(){\n  const [file, setFile] = useState(null);\n  const [result, setResult] = useState(null);\n\n  async function submit(e){\n    e.preventDefault();\n    if (!file) return;\n    const fd = new FormData();\n    fd.append(\"file\", file);\n    try {\n      const r = await verifyFile(fd);\n      setResult(r);\n    } catch(err) {\n      alert(\"Verify failed: \" + err.message);\n    }\n  }\n\n  return (\n    <div className=\"p-6 max-w-2xl mx-auto\">\n      <h1 className=\"text-2xl font-semibold mb-4\">Verify Evidence</h1>\n      <form onSubmit={submit} className=\"bg-white p-4 rounded shadow\">\n        <input type=\"file\" onChange={e=>setFile(e.target.files[0])} />\n        <button className=\"px-3 py-2 bg-green-600 text-white rounded ml-3\" type=\"submit\">Verify</button>\n      </form>\n\n      {result && (\n        <div className=\"bg-white p-4 rounded shadow mt-4\">\n          <h3 className=\"font-semibold\">Result</h3>\n          <pre className=\"text-sm\">{JSON.stringify(result, null, 2)}</pre>\n        </div>\n      )}\n    </div>\n  );\n}\n","size_bytes":1149},"backend/generate_key.py":{"content":"# generate_key.py\nfrom Crypto.PublicKey import RSA\n\nkey = RSA.generate(2048)\nwith open('issuer_priv.pem','wb') as f:\n    f.write(key.export_key())\nwith open('issuer_pub.pem','wb') as f:\n    f.write(key.publickey().export_key())\nprint(\"Issuer keys generated: issuer_priv.pem and issuer_pub.pem\")\n","size_bytes":295},"backend/chain_utils.py":{"content":"# backend/chain_utils.py\nimport hashlib\nimport json\n\ndef sha256_file(path):\n    h = hashlib.sha256()\n    with open(path, 'rb') as f:\n        for chunk in iter(lambda: f.read(8192), b''):\n            h.update(chunk)\n    return h.hexdigest()\n\ndef sha256_bytes(b: bytes):\n    return hashlib.sha256(b).hexdigest()\n\ndef merkle_root(hex_hashes):\n    # hex_hashes: list of hex strings\n    if not hex_hashes:\n        return ''\n    cur = [bytes.fromhex(h) for h in hex_hashes]\n    while len(cur) > 1:\n        if len(cur) % 2 == 1:\n            cur.append(cur[-1])\n        nxt = []\n        for i in range(0, len(cur), 2):\n            nxt.append(hashlib.sha256(cur[i] + cur[i+1]).digest())\n        cur = nxt\n    return cur[0].hex()\n","size_bytes":720},"frontend/src/App.css":{"content":"#root {\n  max-width: 1280px;\n  margin: 0 auto;\n  padding: 2rem;\n  text-align: center;\n}\n\n.logo {\n  height: 6em;\n  padding: 1.5em;\n  will-change: filter;\n  transition: filter 300ms;\n}\n.logo:hover {\n  filter: drop-shadow(0 0 2em #646cffaa);\n}\n.logo.react:hover {\n  filter: drop-shadow(0 0 2em #61dafbaa);\n}\n\n@keyframes logo-spin {\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n}\n\n@media (prefers-reduced-motion: no-preference) {\n  a:nth-of-type(2) .logo {\n    animation: logo-spin infinite 20s linear;\n  }\n}\n\n.card {\n  padding: 2em;\n}\n\n.read-the-docs {\n  color: #888;\n}\n","size_bytes":606},"frontend/vite.config.js":{"content":"import { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\n\n// https://vite.dev/config/\nexport default defineConfig({\n  plugins: [react()],\n})\n","size_bytes":161},"backend/db.py":{"content":"# backend/db.py\nimport sqlite3\nfrom pathlib import Path\n\nDB_PATH = Path(__file__).parent / 'chain.db'\n\ndef get_conn():\n    conn = sqlite3.connect(DB_PATH, check_same_thread=False)\n    conn.row_factory = sqlite3.Row\n    return conn\n\ndef init_db():\n    conn = get_conn()\n    cur = conn.cursor()\n    cur.execute('''\n    CREATE TABLE IF NOT EXISTS blocks (\n      idx INTEGER PRIMARY KEY,\n      timestamp TEXT,\n      previous_hash TEXT,\n      merkle_root TEXT,\n      block_hash TEXT,\n      signature TEXT,\n      nonce INTEGER\n    )''')\n    cur.execute('''\n    CREATE TABLE IF NOT EXISTS transactions (\n      tx_id TEXT PRIMARY KEY,\n      block_idx INTEGER,\n      report_id TEXT,\n      title TEXT,\n      uploader TEXT,\n      metadata TEXT,\n      report_hash TEXT\n    )''')\n    conn.commit()\n    conn.close()\n","size_bytes":802},"frontend/eslint.config.js":{"content":"import js from '@eslint/js'\nimport globals from 'globals'\nimport reactHooks from 'eslint-plugin-react-hooks'\nimport reactRefresh from 'eslint-plugin-react-refresh'\nimport { defineConfig, globalIgnores } from 'eslint/config'\n\nexport default defineConfig([\n  globalIgnores(['dist']),\n  {\n    files: ['**/*.{js,jsx}'],\n    extends: [\n      js.configs.recommended,\n      reactHooks.configs.flat.recommended,\n      reactRefresh.configs.vite,\n    ],\n    languageOptions: {\n      ecmaVersion: 2020,\n      globals: globals.browser,\n      parserOptions: {\n        ecmaVersion: 'latest',\n        ecmaFeatures: { jsx: true },\n        sourceType: 'module',\n      },\n    },\n    rules: {\n      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],\n    },\n  },\n])\n","size_bytes":758},"frontend/src/pages/Explorer.jsx":{"content":"// frontend/src/pages/Explorer.jsx\nimport React, { useEffect, useState } from \"react\";\nimport { explorer, getBlock, getBlockQr, getMerkleProof, downloadCertificate, verifyChain } from \"../api\";\nimport MerkleVisualizer from \"../components/MerkleVisualizer\";\n\nexport default function Explorer() {\n  const [blocks, setBlocks] = useState([]);\n  const [detail, setDetail] = useState(null);\n  const [qrData, setQrData] = useState(null);\n  const [selectedLeaf, setSelectedLeaf] = useState(\"\");\n  const [proofData, setProofData] = useState(null);\n  const [showMerkle, setShowMerkle] = useState(false);\n  const [chainStatus, setChainStatus] = useState(null);\n\n  useEffect(()=>{ loadBlocks(); }, []);\n\n  async function loadBlocks(){\n    try {\n      const data = await explorer();\n      setBlocks(data);\n    } catch(err) {\n      alert(\"Failed to load blocks: \" + err.message);\n    }\n  }\n\n  async function openBlock(idx){\n    try {\n      const d = await getBlock(idx);\n      setDetail(d);\n      setQrData(null);\n      setProofData(null);\n      setShowMerkle(false);\n      // default select first evidence hash if present\n    } catch(err) {\n      alert(\"Failed to open block: \" + err.message);\n    }\n  }\n\n  async function showQr(idx){\n    try {\n      const r = await getBlockQr(idx);\n      setQrData(r);\n    } catch(err) {\n      alert(\"Failed to fetch QR: \" + err.message);\n    }\n  }\n\n  async function fetchMerkle(idx, leaf){\n    try {\n      const res = await getMerkleProof(idx, leaf);\n      setProofData(res);\n      setShowMerkle(true);\n    } catch(err){\n      alert(\"Failed to fetch merkle proof: \" + err.message);\n    }\n  }\n\n  async function downloadCert(reportId) {\n    try {\n      const blob = await downloadCertificate(reportId);\n      const url = URL.createObjectURL(blob);\n      const a = document.createElement(\"a\");\n      a.href = url;\n      a.download = `certificate_${reportId}.pdf`;\n      document.body.appendChild(a);\n      a.click();\n      a.remove();\n      URL.revokeObjectURL(url);\n    } catch (err) {\n      alert(\"Certificate download failed: \" + err.message);\n    }\n  }\n\n  async function checkChain() {\n    try {\n      const res = await verifyChain();\n      setChainStatus(res);\n      if (!res.ok) {\n        alert(\"Chain problems found; open console for details\");\n        console.log(res.problems);\n      } else {\n        alert(\"Chain OK — no problems detected\");\n      }\n    } catch(err) {\n      alert(\"Chain verify failed: \" + err.message);\n    }\n  }\n\n  return (\n    <div className=\"p-6\">\n      <div className=\"flex items-center justify-between mb-4\">\n        <h1 className=\"text-2xl font-semibold\">Block Explorer</h1>\n        <div className=\"flex gap-2\">\n          <button onClick={checkChain} className=\"px-3 py-2 bg-amber-600 text-white rounded\">Verify Chain</button>\n        </div>\n      </div>\n\n      <div className=\"grid grid-cols-3 gap-4\">\n        <div>\n          {blocks.map(b => (\n            <div key={b.idx} className=\"p-3 bg-white rounded shadow mb-2\">\n              <div className=\"font-semibold\">Block #{b.idx}</div>\n              <div className=\"text-xs text-gray-600\">Root: {b.merkle_root?.slice(0,12)}...</div>\n              <div className=\"mt-2 flex gap-2\">\n                <button onClick={()=>openBlock(b.idx)} className=\"text-indigo-600 underline\">View</button>\n                <button onClick={()=>showQr(b.idx)} className=\"text-green-600 underline\">Show QR</button>\n              </div>\n            </div>\n          ))}\n        </div>\n\n        <div className=\"col-span-2\">\n          {detail ? (\n            <div className=\"bg-white p-4 rounded shadow\">\n              <h2 className=\"font-bold\">Block #{detail.idx}</h2>\n              <div className=\"mt-2\"><strong>Timestamp:</strong> {detail.timestamp}</div>\n              <div><strong>Block Hash:</strong> {detail.block_hash}</div>\n              <div><strong>Previous Hash:</strong> {detail.previous_hash}</div>\n              <div><strong>Merkle Root:</strong> {detail.merkle_root}</div>\n\n              <h3 className=\"mt-4 font-semibold\">Transactions</h3>\n              <div className=\"space-y-3\">\n                {detail.transactions.map(tx => (\n                  <div key={tx.tx_id} className=\"p-3 border rounded\">\n                    <div className=\"flex items-center justify-between\">\n                      <div>\n                        <div className=\"font-semibold\">{tx.title}</div>\n                        <div className=\"text-xs text-gray-600\">Uploader: {tx.uploader}</div>\n                        <div className=\"text-xs text-gray-600\">Report: {tx.report_id}</div>\n                      </div>\n                      <div className=\"flex flex-col gap-2\">\n                        <button onClick={() => downloadCert(tx.report_id)} className=\"px-2 py-1 bg-indigo-600 text-white rounded text-sm\">Download PDF</button>\n                        <button onClick={() => {\n                          // try first evidence hash from saved report JSON\n                          const rp = tx.report_id;\n                          fetch(`/api/`) // no-op to hint\n                        }} className=\"px-2 py-1 bg-gray-200 rounded text-sm\">Preview</button>\n                      </div>\n                    </div>\n\n                    <div className=\"mt-3\">\n                      <div className=\"text-sm text-gray-700\">Evidence:</div>\n                      <ul className=\"list-disc ml-6\">\n                        {(() => {\n                          // attempt to read saved report JSON via the frontend by requesting /api/block/<idx> which includes transactions\n                          // but we already have tx.report_id here\n                          const repPath = `/api/report/${tx.report_id}/certificate`; // not used, just for info\n                          return (tx._evidence || []).length ? tx._evidence.map(e => <li key={e.filename}>{e.filename}</li>) : <li className=\"text-xs text-gray-500\">(open report JSON file in uploads folder)</li>\n                        })()}\n                      </ul>\n                    </div>\n\n                    <div className=\"mt-3 flex gap-2\">\n                      <input placeholder=\"paste leaf hash or leave empty\" value={selectedLeaf} onChange={(e)=>setSelectedLeaf(e.target.value)} className=\"px-3 py-1 border rounded\" />\n                      <button onClick={()=>fetchMerkle(detail.idx, selectedLeaf)} className=\"px-3 py-1 bg-green-600 text-white rounded\">Get Merkle Proof</button>\n                    </div>\n                  </div>\n                ))}\n              </div>\n\n              <div className=\"mt-6\">\n                <h4 className=\"font-semibold\">QR Verification</h4>\n                <div className=\"mt-2\">\n                  {qrData && (\n                    <div className=\"p-3 bg-gray-50 rounded inline-block\">\n                      <img alt=\"qr\" src={`data:image/png;base64,${qrData.qr_base64}`} />\n                      <div className=\"text-xs text-gray-600 mt-2\">\n                        Or open: <a className=\"text-indigo-600\" href={qrData.verification_url} target=\"_blank\" rel=\"noreferrer\">{qrData.verification_url}</a>\n                      </div>\n                    </div>\n                  )}\n                </div>\n              </div>\n\n            </div>\n          ) : <div className=\"text-gray-600\">Select a block to view details</div>}\n        </div>\n      </div>\n\n      {showMerkle && proofData && (\n        <div className=\"fixed inset-0 bg-black/50 flex items-center justify-center p-6\">\n          <div className=\"bg-white p-6 rounded max-w-2xl w-full\">\n            <h3 className=\"text-xl font-semibold mb-2\">Merkle proof for leaf</h3>\n            <div className=\"mb-2\">Leaf: <code className=\"bg-gray-100 px-2 py-1 rounded\">{proofData.leaf}</code></div>\n            <MerkleVisualizer proof={proofData.proof} leaf={proofData.leaf} root={proofData.root} valid={proofData.valid} />\n            <div className=\"mt-4 text-right\">\n              <button onClick={()=>{ setShowMerkle(false); setProofData(null); }} className=\"px-3 py-2 bg-gray-300 rounded\">Close</button>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {chainStatus && (\n        <div className=\"mt-6 bg-yellow-50 p-3 rounded\">\n          <div className=\"font-semibold\">Chain Verify Result</div>\n          <pre className=\"text-sm\">{JSON.stringify(chainStatus, null, 2)}</pre>\n        </div>\n      )}\n    </div>\n  );\n}\n","size_bytes":8355},"frontend/src/api.js":{"content":"// frontend/src/api.js\nconst API_BASE = \"http://127.0.0.1:5001/api\";\n\nasync function fetchJson(url, opts = {}) {\n  const res = await fetch(url, opts);\n  if (!res.ok) {\n    const txt = await res.text().catch(()=>\"(no body)\");\n    throw new Error(`Request failed ${res.status} ${res.statusText} -> ${txt}`);\n  }\n  const ct = res.headers.get(\"content-type\") || \"\";\n  if (!ct.includes(\"application/json\") && !ct.includes(\"application/pdf\")) {\n    const txt = await res.text().catch(()=>\"(no body)\");\n    throw new Error(`Expected JSON or PDF but got: ${txt}`);\n  }\n  return res;\n}\n\nexport async function createReport(formData) {\n  const res = await fetchJson(`${API_BASE}/report`, { method: \"POST\", body: formData });\n  return res.json();\n}\n\nexport async function explorer() {\n  const res = await fetchJson(`${API_BASE}/explorer`);\n  return res.json();\n}\n\nexport async function getBlock(idx) {\n  const res = await fetchJson(`${API_BASE}/block/${idx}`);\n  return res.json();\n}\n\nexport async function verifyFile(formData) {\n  const res = await fetchJson(`${API_BASE}/verify`, { method: \"POST\", body: formData });\n  return res.json();\n}\n\nexport async function getBlockQr(idx) {\n  const res = await fetchJson(`${API_BASE}/block/${idx}/qr`);\n  return res.json();\n}\n\nexport async function searchReports(query) {\n  const res = await fetchJson(`${API_BASE}/search?q=${encodeURIComponent(query)}`);\n  return res.json();\n}\n\n// NEW:\nexport async function getMerkleProof(blockIdx, leaf) {\n  const url = `${API_BASE}/block/${blockIdx}/merkle?leaf=${encodeURIComponent(leaf || \"\")}`;\n  const res = await fetchJson(url);\n  return res.json();\n}\n\nexport async function downloadCertificate(reportId) {\n  const url = `${API_BASE}/report/${encodeURIComponent(reportId)}/certificate`;\n  // fetch the PDF blob\n  const res = await fetch(url);\n  if (!res.ok) {\n    const txt = await res.text().catch(()=>\"(no body)\");\n    throw new Error(`Certificate request failed: ${res.status} -> ${txt}`);\n  }\n  const blob = await res.blob();\n  return blob;\n}\n\nexport async function verifyChain() {\n  const res = await fetchJson(`${API_BASE}/chain/verify`);\n  return res.json();\n}\n\nexport async function getTimeline() {\n  const res = await fetchJson(`${API_BASE}/chain/timeline`);\n  return res.json();\n}\n","size_bytes":2264},"backend/app.py":{"content":"# backend/app.py\nimport os\nimport time\nimport json\nimport uuid\nimport hashlib\nimport sqlite3\nimport base64\nfrom io import BytesIO\nfrom pathlib import Path\nfrom flask import Flask, request, jsonify, send_file, abort\nfrom flask_cors import CORS\n\ntry:\n    import qrcode\nexcept Exception:\n    qrcode = None\n\ntry:\n    from reportlab.lib.pagesizes import A4\n    from reportlab.pdfgen import canvas\n    from reportlab.lib.utils import ImageReader\nexcept Exception:\n    # reportlab may not be installed\n    canvas = None\n\nBASE_DIR = Path(__file__).parent\nUPLOAD_DIR = BASE_DIR / \"uploads\"\nDB_PATH = BASE_DIR / \"chain.db\"\nUPLOAD_DIR.mkdir(parents=True, exist_ok=True)\n\napp = Flask(__name__)\nCORS(app)\n\n# ----------------------\n# Utilities\n# ----------------------\ndef sha256_bytes(b: bytes) -> str:\n    return hashlib.sha256(b).hexdigest()\n\ndef sha256_file(path: Path) -> str:\n    h = hashlib.sha256()\n    with open(path, \"rb\") as f:\n        for chunk in iter(lambda: f.read(8192), b\"\"):\n            h.update(chunk)\n    return h.hexdigest()\n\ndef merkle_root(hash_list):\n    # simple merkle: if empty -> '', if single -> that hash, else pairwise combine\n    if not hash_list:\n        return \"\"\n    cur = [h for h in hash_list]\n    while len(cur) > 1:\n        nxt = []\n        for i in range(0, len(cur), 2):\n            a = cur[i]\n            b = cur[i+1] if i+1 < len(cur) else cur[i]\n            nxt.append(hashlib.sha256((a + b).encode()).hexdigest())\n        cur = nxt\n    return cur[0]\n\ndef merkle_proof(hash_list, leaf):\n    \"\"\"\n    Returns proof list for leaf (hex strings).\n    proof format: list of { 'sibling': <hex>, 'position': 'left'|'right' }\n    where sibling is the hash paired with current node.\n    \"\"\"\n    # if leaf is not present, return None\n    if leaf not in hash_list:\n        return None\n    # map to current layer\n    layer = [h for h in hash_list]\n    proof = []\n    idx = layer.index(leaf)\n    while len(layer) > 1:\n        nxt = []\n        for i in range(0, len(layer), 2):\n            a = layer[i]\n            b = layer[i+1] if i+1 < len(layer) else layer[i]\n            # if current pair contains leaf or its ancestor, record sibling\n            if i == idx or i+1 == idx:\n                # sibling is the other one\n                if i == idx:\n                    sibling = b\n                    position = \"right\"\n                else:\n                    sibling = a\n                    position = \"left\"\n                proof.append({\"sibling\": sibling, \"position\": position})\n                # new idx is index in nxt\n                new_hash = hashlib.sha256((a + b).encode()).hexdigest()\n                nxt.append(new_hash)\n                idx = len(nxt) - 1\n            else:\n                new_hash = hashlib.sha256((a + b).encode()).hexdigest()\n                nxt.append(new_hash)\n        layer = nxt\n    return proof\n\n# ----------------------\n# DB init\n# ----------------------\ndef get_conn():\n    conn = sqlite3.connect(DB_PATH)\n    conn.row_factory = sqlite3.Row\n    return conn\n\ndef init_db():\n    conn = get_conn()\n    c = conn.cursor()\n    # blocks: idx integer primary key, timestamp, previous_hash, merkle_root, block_hash\n    c.execute(\"\"\"\n    CREATE TABLE IF NOT EXISTS blocks (\n        idx INTEGER PRIMARY KEY,\n        timestamp TEXT,\n        previous_hash TEXT,\n        merkle_root TEXT,\n        block_hash TEXT\n    )\n    \"\"\")\n    # transactions: tx_id, block_idx, report_id, title, uploader, metadata (json), report_hash\n    c.execute(\"\"\"\n    CREATE TABLE IF NOT EXISTS transactions (\n        tx_id TEXT PRIMARY KEY,\n        block_idx INTEGER,\n        report_id TEXT,\n        title TEXT,\n        uploader TEXT,\n        metadata TEXT,\n        report_hash TEXT\n    )\n    \"\"\")\n    conn.commit()\n    conn.close()\n\ninit_db()\n\ndef get_last_block_row(conn):\n    c = conn.cursor()\n    c.execute(\"SELECT * FROM blocks ORDER BY idx DESC LIMIT 1\")\n    return c.fetchone()\n\n# ----------------------\n# Basic endpoints (existing)\n# ----------------------\n\n@app.route(\"/api/explorer\", methods=[\"GET\"])\ndef explorer():\n    conn = get_conn()\n    c = conn.cursor()\n    c.execute(\"SELECT idx, timestamp, block_hash, merkle_root FROM blocks ORDER BY idx DESC LIMIT 100\")\n    rows = [dict(r) for r in c.fetchall()]\n    conn.close()\n    return jsonify(rows)\n\n@app.route(\"/api/block/<int:idx>\", methods=[\"GET\"])\ndef get_block(idx):\n    conn = get_conn()\n    c = conn.cursor()\n    c.execute(\"SELECT * FROM blocks WHERE idx=?\", (idx,))\n    b = c.fetchone()\n    if not b:\n        conn.close()\n        return jsonify({\"error\": \"block not found\"}), 404\n    c.execute(\"SELECT * FROM transactions WHERE block_idx=?\", (idx,))\n    txs = [dict(r) for r in c.fetchall()]\n    conn.close()\n    out = dict(b)\n    out[\"transactions\"] = txs\n    return jsonify(out)\n\n@app.route(\"/api/report\", methods=[\"POST\"])\ndef create_report():\n    title = request.form.get(\"title\", \"Untitled\")\n    uploader = request.form.get(\"uploader\", \"anonymous\")\n    description = request.form.get(\"description\", \"\")\n    metadata = {\n        \"description\": description,\n        \"location\": request.form.get(\"location\", \"\"),\n        \"time\": request.form.get(\"time\", \"\")\n    }\n\n    files = request.files.getlist(\"files\")\n    evidence = []\n    for f in files:\n        filename = f.filename or (\"file_\" + uuid.uuid4().hex)\n        unique = f\"{uuid.uuid4().hex}_{filename}\"\n        path = UPLOAD_DIR / unique\n        f.save(path)\n        file_hash = sha256_file(path)\n        evidence.append({\n            \"filename\": unique,\n            \"sha256\": file_hash,\n            \"mimetype\": f.mimetype,\n            \"size\": path.stat().st_size\n        })\n\n    report = {\n        \"report_id\": uuid.uuid4().hex,\n        \"title\": title,\n        \"uploader\": uploader,\n        \"metadata\": metadata,\n        \"evidence\": evidence\n    }\n    report_bytes = json.dumps(report, sort_keys=True).encode()\n    report_hash = sha256_bytes(report_bytes)\n\n    # transaction id\n    tx_id = \"tx_\" + uuid.uuid4().hex\n\n    # compute merkle root using evidence hashes + report_hash\n    ev_hashes = [e[\"sha256\"] for e in evidence] + [report_hash]\n    root = merkle_root(ev_hashes)\n\n    # create block\n    conn = get_conn()\n    last = get_last_block_row(conn)\n    prev_hash = last[\"block_hash\"] if last else \"0\" * 64\n    timestamp = time.strftime(\"%Y-%m-%dT%H:%M:%S%z\")\n    c = conn.cursor()\n    # block index\n    idx = (last[\"idx\"] + 1) if last else 0\n    # payload used to compute hash (same structure as earlier)\n    block_payload = {\"idx\": idx, \"timestamp\": timestamp, \"previous_hash\": prev_hash, \"merkle_root\": root, \"transactions\": [tx_id]}\n    block_hash = sha256_bytes(json.dumps(block_payload, sort_keys=True).encode())\n\n    c.execute(\"INSERT INTO blocks (idx, timestamp, previous_hash, merkle_root, block_hash) VALUES (?, ?, ?, ?, ?)\",\n              (idx, timestamp, prev_hash, root, block_hash))\n    c.execute(\"INSERT INTO transactions (tx_id, block_idx, report_id, title, uploader, metadata, report_hash) VALUES (?, ?, ?, ?, ?, ?, ?)\",\n              (tx_id, idx, report[\"report_id\"], title, uploader, json.dumps(metadata), report_hash))\n    conn.commit()\n    conn.close()\n\n    # save report JSON alongside uploads for later reference\n    with open(UPLOAD_DIR / (report[\"report_id\"] + \".json\"), \"wb\") as fh:\n        fh.write(report_bytes)\n\n    return jsonify({\n        \"report_id\": report[\"report_id\"],\n        \"tx_id\": tx_id,\n        \"block_index\": idx,\n        \"block_hash\": block_hash\n    }), 201\n\n@app.route(\"/api/verify\", methods=[\"POST\"])\ndef verify_file():\n    f = request.files.get(\"file\")\n    if not f:\n        return jsonify({\"error\": \"no file provided\"}), 400\n    tmp = UPLOAD_DIR / (\"tmp_\" + uuid.uuid4().hex)\n    f.save(tmp)\n    h = sha256_file(tmp)\n    matches = []\n    conn = get_conn()\n    c = conn.cursor()\n    c.execute(\"SELECT t.*, b.block_hash, b.merkle_root, b.idx FROM transactions t JOIN blocks b ON t.block_idx=b.idx\")\n    for r in c.fetchall():\n        report_id = r[\"report_id\"]\n        report_path = UPLOAD_DIR / (report_id + \".json\")\n        if report_path.exists():\n            rep = json.loads(report_path.read_bytes())\n            for e in rep.get(\"evidence\", []):\n                if e.get(\"sha256\") == h:\n                    matches.append({\n                        \"tx_id\": r[\"tx_id\"],\n                        \"report_id\": report_id,\n                        \"block_idx\": r[\"block_idx\"],\n                        \"block_hash\": r[\"block_hash\"],\n                        \"merkle_root\": r[\"merkle_root\"]\n                    })\n    conn.close()\n    tmp.unlink(missing_ok=True)\n    return jsonify({\"matches\": matches})\n\n@app.route(\"/api/block/<int:idx>/qr\", methods=[\"GET\"])\ndef block_qr(idx):\n    frontend_origin = os.environ.get(\"FRONTEND_ORIGIN\", \"http://localhost:5173\")\n    verification_url = f\"{frontend_origin}/explorer?block={idx}\"\n    if qrcode is None:\n        return jsonify({\"error\": \"qrcode library not installed\", \"verification_url\": verification_url})\n    img = qrcode.make(verification_url)\n    buf = BytesIO()\n    img.save(buf, format=\"PNG\")\n    buf.seek(0)\n    b64 = base64.b64encode(buf.read()).decode()\n    return jsonify({\"qr_base64\": b64, \"verification_url\": verification_url})\n\n# ----------------------\n# NEW: Merkle proof endpoint\n# ----------------------\n@app.route(\"/api/block/<int:idx>/merkle\", methods=[\"GET\"])\ndef block_merkle(idx):\n    \"\"\"\n    Query params:\n      - leaf=<sha256 hex of evidence or report hash>\n    Returns: {\n      \"root\": \"<merkle_root>\",\n      \"proof\": [ { \"sibling\": \"<hex>\", \"position\": \"left\"|\"right\" }, ... ],\n      \"leaf\": \"<leaf>\",\n      \"valid\": true/false\n    }\n    \"\"\"\n    leaf = request.args.get(\"leaf\", \"\").strip()\n    conn = get_conn()\n    c = conn.cursor()\n    c.execute(\"SELECT * FROM blocks WHERE idx=?\", (idx,))\n    b = c.fetchone()\n    if not b:\n        conn.close()\n        return jsonify({\"error\": \"block not found\"}), 404\n\n    # Collect evidence hashes and report_hash for this block (from transactions)\n    c.execute(\"SELECT report_id FROM transactions WHERE block_idx=?\", (idx,))\n    rows = c.fetchall()\n    ev_hashes = []\n    for r in rows:\n        report_id = r[\"report_id\"]\n        report_path = UPLOAD_DIR / (report_id + \".json\")\n        if report_path.exists():\n            rep = json.loads(report_path.read_bytes())\n            # append evidence hashes\n            for e in rep.get(\"evidence\", []):\n                ev_hashes.append(e.get(\"sha256\"))\n            # append report hash (recompute)\n            rep_bytes = json.dumps(rep, sort_keys=True).encode()\n            rep_hash = sha256_bytes(rep_bytes)\n            ev_hashes.append(rep_hash)\n    # dedupe (keep order) and ensure non-empty\n    ev_hashes = [h for i, h in enumerate(ev_hashes) if h and h not in ev_hashes[:i]]\n\n    root = b[\"merkle_root\"]\n    if not ev_hashes:\n        conn.close()\n        return jsonify({\"error\": \"no evidence hashes for block\"}), 400\n\n    if not leaf:\n        # default leaf: use last element (report hash) for demonstration\n        leaf = ev_hashes[-1]\n\n    proof = merkle_proof(ev_hashes, leaf)\n    valid = False\n    if proof is not None:\n        # verify proof locally\n        cur = leaf\n        for p in proof:\n            sib = p[\"sibling\"]\n            if p[\"position\"] == \"left\":\n                cur = hashlib.sha256((sib + cur).encode()).hexdigest()\n            else:\n                cur = hashlib.sha256((cur + sib).encode()).hexdigest()\n        valid = (cur == root)\n    conn.close()\n    return jsonify({\"root\": root, \"proof\": proof, \"leaf\": leaf, \"valid\": valid, \"all_leaves\": ev_hashes})\n\n# ----------------------\n# NEW: Certificate PDF generation\n# ----------------------\n@app.route(\"/api/report/<report_id>/certificate\", methods=[\"GET\"])\ndef report_certificate(report_id):\n    \"\"\"\n    Returns a generated PDF certificate for the report_id.\n    \"\"\"\n    # must have report JSON saved\n    report_path = UPLOAD_DIR / (f\"{report_id}.json\")\n    if not report_path.exists():\n        return jsonify({\"error\": \"report JSON not found\"}), 404\n\n    report = json.loads(report_path.read_bytes())\n    # find the transaction & block info\n    conn = get_conn()\n    c = conn.cursor()\n    c.execute(\"SELECT * FROM transactions WHERE report_id=?\", (report_id,))\n    tx = c.fetchone()\n    if not tx:\n        conn.close()\n        return jsonify({\"error\": \"transaction not found\"}), 404\n    block_idx = tx[\"block_idx\"]\n    c.execute(\"SELECT * FROM blocks WHERE idx=?\", (block_idx,))\n    blk = c.fetchone()\n    conn.close()\n\n    # Prepare PDF in-memory\n    if canvas is None:\n        # reportlab not installed; return JSON describing certificate\n        return jsonify({\n            \"warning\": \"reportlab not installed on server; install reportlab to enable PDF generation\",\n            \"report\": report,\n            \"transaction\": dict(tx),\n            \"block\": dict(blk) if blk else None\n        }), 200\n\n    buf = BytesIO()\n    cpdf = canvas.Canvas(buf, pagesize=A4)\n    width, height = A4\n    # Title\n    cpdf.setFont(\"Helvetica-Bold\", 18)\n    cpdf.drawString(40, height - 60, \"BlockWitness — Evidence Certificate\")\n    cpdf.setFont(\"Helvetica\", 12)\n    cpdf.drawString(40, height - 90, f\"Report ID: {report_id}\")\n    cpdf.drawString(40, height - 110, f\"Title: {report.get('title')}\")\n    cpdf.drawString(40, height - 130, f\"Uploader: {report.get('uploader')}\")\n    cpdf.drawString(40, height - 150, f\"Block Index: {block_idx}\")\n    if blk:\n        cpdf.drawString(40, height - 170, f\"Block Hash: {blk['block_hash']}\")\n        cpdf.drawString(40, height - 190, f\"Timestamp: {blk['timestamp']}\")\n\n    # Draw a small thumbnail if evidence exists\n    thumb_y = height - 320\n    try:\n        thumb_path = None\n        if report.get(\"evidence\"):\n            # try first evidence file\n            fn = report[\"evidence\"][0].get(\"filename\")\n            p = UPLOAD_DIR / fn\n            if p.exists():\n                thumb_path = p\n        # fallback to demo file if not found\n        if not thumb_path:\n            thumb_path = Path(\"/mnt/data/8c099852-aacd-4177-bd7b-db36ae98c0d2.png\")\n        if thumb_path.exists():\n            img_reader = ImageReader(str(thumb_path))\n            cpdf.drawImage(img_reader, 40, thumb_y, width=200, height=120, preserveAspectRatio=True)\n    except Exception as e:\n        # ignore thumbnail errors\n        pass\n\n    # Add a block of metadata text\n    desc = report.get(\"metadata\", {}).get(\"description\", \"\")\n    cpdf.setFont(\"Helvetica\", 10)\n    text = cpdf.beginText(260, thumb_y + 100)\n    text.textLines(f\"Description: {desc}\\n\\nThis certificate proves the report was recorded in the local BlockWitness ledger. Verify at the BlockWitness Explorer using the block hash or the report ID.\")\n    cpdf.drawText(text)\n\n    # Footer\n    cpdf.setFont(\"Helvetica-Oblique\", 9)\n    cpdf.drawString(40, 50, \"Generated by BlockWitness (demo) — not a legal document.\")\n    cpdf.showPage()\n    cpdf.save()\n    buf.seek(0)\n    return send_file(buf, mimetype=\"application/pdf\", download_name=f\"certificate_{report_id}.pdf\", as_attachment=True)\n\n# ----------------------\n# NEW: Chain integrity & timeline endpoints\n# ----------------------\n@app.route(\"/api/chain/verify\", methods=[\"GET\"])\ndef chain_verify():\n    \"\"\"\n    Recompute block hashes from stored fields and transaction lists, and verify previous_hash chain.\n    Returns a list of problems (empty list means chain is OK).\n    \"\"\"\n    conn = get_conn()\n    c = conn.cursor()\n    c.execute(\"SELECT * FROM blocks ORDER BY idx ASC\")\n    blocks = [dict(r) for r in c.fetchall()]\n    problems = []\n    prev_hash = None\n    for b in blocks:\n        idx = b[\"idx\"]\n        # gather tx ids for this block\n        c.execute(\"SELECT tx_id FROM transactions WHERE block_idx=?\", (idx,))\n        txs = [r[\"tx_id\"] for r in c.fetchall()]\n        payload = {\"idx\": idx, \"timestamp\": b[\"timestamp\"], \"previous_hash\": b[\"previous_hash\"], \"merkle_root\": b[\"merkle_root\"], \"transactions\": txs}\n        recomputed = sha256_bytes(json.dumps(payload, sort_keys=True).encode())\n        if recomputed != b[\"block_hash\"]:\n            problems.append({\"idx\": idx, \"issue\": \"block_hash_mismatch\", \"expected\": b[\"block_hash\"], \"recomputed\": recomputed})\n        if prev_hash is not None and b[\"previous_hash\"] != prev_hash:\n            problems.append({\"idx\": idx, \"issue\": \"previous_hash_mismatch\", \"expected_prev\": prev_hash, \"got\": b[\"previous_hash\"]})\n        prev_hash = b[\"block_hash\"]\n    conn.close()\n    return jsonify({\"ok\": len(problems) == 0, \"problems\": problems})\n\n@app.route(\"/api/chain/timeline\", methods=[\"GET\"])\ndef chain_timeline():\n    \"\"\"\n    Returns blocks ordered descending with basic tx info for frontend timeline UI.\n    \"\"\"\n    conn = get_conn()\n    c = conn.cursor()\n    c.execute(\"SELECT * FROM blocks ORDER BY idx DESC\")\n    blocks = []\n    for b in c.fetchall():\n        idx = b[\"idx\"]\n        c.execute(\"SELECT tx_id, title, uploader, report_id FROM transactions WHERE block_idx=? ORDER BY tx_id\", (idx,))\n        txs = [dict(r) for r in c.fetchall()]\n        blocks.append({\n            \"idx\": b[\"idx\"],\n            \"timestamp\": b[\"timestamp\"],\n            \"block_hash\": b[\"block_hash\"],\n            \"merkle_root\": b[\"merkle_root\"],\n            \"transactions\": txs\n        })\n    conn.close()\n    return jsonify(blocks)\n\nif __name__ == \"__main__\":\n    # listen on all interfaces for LAN testing; change host if you prefer localhost only\n    app.run(host=\"0.0.0.0\", port=5001, debug=True)\n","size_bytes":17407},"frontend/src/main.jsx":{"content":"import './index.css'\nimport React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport App from './App'\n\nReactDOM.createRoot(document.getElementById('root')).render(\n  <React.StrictMode><App /></React.StrictMode>\n)\n","size_bytes":222}},"version":2}